package openai

import (
	"bufio"
	"context"
	"io"
	"mime/multipart"
	"net/http"
	"os"
	"path"

	jsoniter "github.com/json-iterator/go"
	"github.com/pkg/errors"
)

type AIRequest struct {
	IsStream bool
	httpReq  *http.Request
	client   *http.Client
}

type AIReqOption interface {
	Set(r *AIRequest)
}

type HeadOption struct {
	Header map[string]string
}

func (r *AIRequest) WithOptions(opts ...AIReqOption) *AIRequest {
	for _, opt := range opts {
		opt.Set(r)
	}
	return r
}

func (o HeadOption) Set(r *AIRequest) {
	if len(o.Header) == 0 {
		return
	}
	for k, v := range o.Header {
		r.httpReq.Header.Set(k, v)
	}
}

// https://platform.openai.com/docs/api-reference/chat/create
type OpenAIChatParam struct {
	Model       string    `json:"model"`
	Message     []Message `json:"messages"`
	Temperature float64   `json:"temperature,omitempty"`
	// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
	// So 0.1 means only the tokens comprising the top 10% probability mass are considered.
	// We generally recommend altering this or temperature but not both.
	TopP             float64  `json:"top_p,omitempty"`
	N                int      `json:"n,omitempty"`
	Stream           bool     `json:"stream"`
	Stop             []string `json:"stop,omitempty"`
	MaxTokens        int64    `json:"max_tokens,omitempty"`
	FrequencyPenalty int      `json:"frequency_penalty"`
	PresencePenalty  float64  `json:"presence_penalty"`
	Seed             uint64   `json:"seed,omitempty"`
	User             string   `json:"user,omitempty"`
}

type OpenAIFileCreateParam struct {
	File     io.Reader `json:"file"`
	FileName string    `json:"file_name"`
	Purpose  string    `json:"purpose"`
	writer   *multipart.Writer
}

func (p *OpenAIFileCreateParam) buildMultipartWriter(body io.Writer) error {
	p.writer = multipart.NewWriter(body)
	if p.Purpose == "" {
		return errors.New("purpose is required")
	}
	err := p.writer.WriteField("purpose", p.Purpose)
	if err != nil {
		return err
	}
	if p.File == nil && p.FileName != "" {
		fileData, err := os.Open(p.FileName)
		if err != nil {
			return err
		}
		defer fileData.Close()
		p.File = fileData
	}
	if p.File == nil {
		return errors.New("file is required")
	}
	w, err := p.writer.CreateFormFile("file", path.Base(p.FileName))
	if err != nil {
		return err
	}
	_, err = io.Copy(w, p.File)
	if err != nil {
		return err
	}

	err = p.writer.Close()

	return err
}

// https://platform.openai.com/docs/api-reference/files/object
type FileInfo struct {
	ID            string `json:"id"`             // The file identifier, which can be referenced in the API endpoints.
	Bytes         int    `json:"bytes"`          // The size of the file, in bytes.
	CreatedAt     int64  `json:"created_at"`     //The Unix timestamp (in seconds) for when the file was created.
	FileName      string `json:"filename"`       // The name of the file.
	Object        string `json:"object"`         // The object type, which is always file.
	Purpose       string `json:"purpose"`        // The intended purpose of the file. Supported values are assistants, assistants_output, batch, batch_output, fine-tune, fine-tune-results and vision.
	Status        string `json:"status"`         // Deprecated
	StatusDetails string `json:"status_details"` // Deprecated
}

type Message struct {
	Role       Role       `json:"role"`
	Name       string     `json:"name,omitempty"`
	Content    MsgContent `json:"content"`
	Refusal    string     `json:"refusal,omitempty"` // The refusal message generated by the model.
	ToolCalls  []ToolFunc `json:"tool_calls,omitempty"`
	ToolCallID string     `json:"tool_call_id,omitempty"`
}

type MsgBase struct {
	Role       Role       `json:"role"`
	Name       string     `json:"name,omitempty"`
	Refusal    string     `json:"refusal,omitempty"` // The refusal message generated by the model.
	ToolCalls  []ToolFunc `json:"tool_calls,omitempty"`
	ToolCallID string     `json:"tool_call_id,omitempty"`
}

func (p *Message) UnmarshalJSON(input []byte) error {
	baseMsg := new(MsgBase)
	if err := jsoniter.Unmarshal(input, baseMsg); err != nil {
		return err
	}
	p.Name = baseMsg.Name
	p.Role = baseMsg.Role
	p.Refusal = baseMsg.Refusal
	p.ToolCalls = baseMsg.ToolCalls
	p.ToolCallID = baseMsg.ToolCallID

	iter := jsoniter.ParseBytes(jsoniter.ConfigCompatibleWithStandardLibrary, input)

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		// 略过非content字段
		if field != "content" {
			// 当前迭代器继续向后迭代，直到找到content字段
			iter.Read()
			continue
		}

		nextType := iter.WhatIsNext()
		if nextType == jsoniter.StringValue {
			// 如果读到的是字符串，则直接赋值
			p.Content = TextContent(iter.ReadString())
		}
		if nextType == jsoniter.ArrayValue {
			userArrContent := make(UserArrContent, 0, 10)
			for iter.ReadArray() {
				tmpItr := *iter
				for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
					contentItem := contentItemMatcher.MatchContentItem(field)
					if contentItem == nil {
						iter.Read()
						continue
					}
					tmpItr.ReadVal(contentItem)
					userArrContent = append(userArrContent, contentItem)
					break
				}
				*iter = tmpItr
			}
			p.Content = userArrContent
		}
		break
	}
	return nil
}

type Role string

const (
	RoleSystem    Role = "system"
	RoleUser      Role = "user"
	RoleAssistant Role = "assistant"
)

type MsgContent interface {
	ContentType() string
	MatchRole(role Role) bool
	Text() []string
	CastToTextContent() (TextContent, bool)
	CastToUserArrContent() (UserArrContent, bool)
}

// implement MsgContent
type TextContent string

func (c TextContent) ContentType() string {
	return "text"
}

func (c TextContent) MatchRole(role Role) bool {
	return true
}

func (c TextContent) Text() []string {
	return []string{string(c)}
}
func (c TextContent) CastToTextContent() (TextContent, bool) {
	return c, true
}

func (c TextContent) CastToUserArrContent() (UserArrContent, bool) {
	return nil, false
}

// implement MsgContent
type UserArrContent []UserArrContentItem

func (c UserArrContent) ContentType() string {
	return "user_array"
}

func (c UserArrContent) MatchRole(role Role) bool {
	return role == RoleUser
}

func (c UserArrContent) Text() []string {
	texts := make([]string, 0, len(c))
	for _, item := range c {
		text := item.GetText()
		if text == "" {
			continue
		}
		texts = append(texts, text)
	}
	return texts
}

func (c UserArrContent) CastToTextContent() (TextContent, bool) {
	return "", false
}

func (c UserArrContent) CastToUserArrContent() (UserArrContent, bool) {
	return c, true
}

type UserArrContentItem interface {
	GetType() string
	Keyword() string
	GetText() string
	CastToUserArrTextContent() (UserTextContent, bool)
	CastToUserArrImgContent() (UserImgContent, bool)
}

// array消息内容元素匹配器，用于解析array型content字段时，匹配到合适的元素类型
type ArrMsgContentItemMatcher interface {
	MatchContentItem(keyword string) UserArrContentItem
}

var contentItemMatcher ArrMsgContentItemMatcher = DefaultArrMsgContentItemMatcher{}

func SetArrMsgContentItemMatcher(matcher ArrMsgContentItemMatcher) {
	contentItemMatcher = matcher
}

type DefaultArrMsgContentItemMatcher struct{}

func (DefaultArrMsgContentItemMatcher) MatchContentItem(keyword string) UserArrContentItem {
	switch keyword {
	case "text":
		return new(UserTextContent)
	case "image_url":
		return new(UserImgContent)
	}
	return nil
}

// implement UserArrContentItem
type UserTextContent struct {
	Type string `json:"type,omitempty"`
	Text string `json:"text"`
}

func (i UserTextContent) GetType() string {
	return i.Type
}

func (i UserTextContent) Keyword() string {
	return "text"
}

func (i UserTextContent) GetText() string {
	return i.Text
}

func (i UserTextContent) CastToUserArrTextContent() (UserTextContent, bool) {
	return i, true
}

func (i UserTextContent) CastToUserArrImgContent() (UserImgContent, bool) {
	return UserImgContent{}, false
}

type ImgURL struct {
	URL    string `json:"url"`
	Detail string `json:"detail,omitempty"`
}

// implement UserArrContentItem
type UserImgContent struct {
	Type     string `json:"type,omitempty"`
	ImageURL ImgURL `json:"image_url"`
}

func (i UserImgContent) GetType() string {
	return i.Type
}

func (i UserImgContent) Keyword() string {
	return "image_url"
}

func (i UserImgContent) GetText() string {
	return ""
}

func (i UserImgContent) CastToUserArrTextContent() (UserTextContent, bool) {
	return UserTextContent{}, false
}

func (i UserImgContent) CastToUserArrImgContent() (UserImgContent, bool) {
	return i, true
}

type ToolFunc struct {
	ID       string `json:"id"`
	Type     string `json:"type"`
	Function struct {
		Name      string `json:"name"`      // The name of the function to call.
		Arguments string `json:"arguments"` // The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
	} `json:"function"`
}

func (r *AIRequest) GetResp(ctx context.Context) (*RespOpenAI, error) {
	resp := &RespOpenAI{
		IsStream:          r.IsStream,
		EmptyMsgLineLimit: 300,
	}
	var err error
	resp.httpResp, err = r.client.Do(r.httpReq)
	if err != nil {
		return nil, errors.Wrap(err, "send msg to ai error")
	}
	if r.IsStream {
		resp.respReader = bufio.NewReader(resp.httpResp.Body)
	}

	return resp, nil
}
